<Title Value=".NET Community Blazor Introduction | Demo 8"></Title>

@if (Context is not null)
{
    <FullTileContainer ChecklistContext="@Context">
        <DemoStartPoint>
            <Capgemini.Net.Blazor.Components.Demo08.Start.WrapperComponent />
        </DemoStartPoint>
        <DemoEndPoint>
            <Capgemini.Net.Blazor.Components.Demo08.End.WrapperComponent />
        </DemoEndPoint>
    </FullTileContainer>
}


@code {
    internal static readonly RenderFragment PointContext1 = __builder =>
    {
    <p>
        Replace all custom properties of the <mark>./Start/RateContext.cs</mark> file with auto-generated properties. Preserve default values
        from private fields (<mark>maxRate = 6</mark> and <mark>avgRate = 3</mark>):
    </p>

    <pre data-line="12, 14, 16">
    <code class="language-csharp line-numbers">
namespace Capgemini.Net.Blazor.Components.Demo08.Start
{
    public class RateContext
    {
        public static readonly string[] Icons = {
            "fa-star",
            "fa-grin-stars",
            "fa-angry",
            "fa-sun"
        };

        public int MaxRate { get; set; } = 6;

        public int AvgRate { get; set; } = 3;

        public string Icon { get; set; } = Icons[0];
    }
}
        </code>
        </pre>

    <p>
        <strong>Note:</strong> as the <mark>CapSelect</mark> component was used to render the drop-down list for the <mark>Icons</mark> array,
        there is also no need to keep the <mark>IconIndex</mark> property with its custom setter (<mark>CapSelect</mark> renders its options
        through the <mark>@@for (int i = 0; i &lt; RateContext.Icons.Length; i += 1)</mark> loop).
    </p>

    <p>
        Modify the markup of the <mark>ContainerComponent.razor</mark> file to make the <mark>CapSelect</mark> component to work directly on the <strong>CSS</strong> classes provided by the <strong>Font Awesome</strong>
        library. As the component no longer needs to handle converting index value of the <mark>Icons</mark> array to one of its value, <mark>ParseValue="@@((option) =&gt; RateContext.Icons[option])"&gt;</mark>
        delegate can be removed, loop simplified:
    </p>

    <pre data-line="1, 2, 4">
    <code class="language-csharp line-numbers">
&lt;CapSelect Label="Icon" @@bind-Value="rateContext.IconIndex" <mark>ParseValue="@@((option) =&gt; RateContext.Icons[option])"&gt;</mark>
	@@for (int i = 0; i &lt; RateContext.Icons.Length; i += 1)
	{
		string icon = RateContext.Icons[i];
		&lt;CapOption Key="@@i.ToString()" Value="@@i"&gt;
			&lt;div class="fa-cap-option"&gt;
				&lt;i class="far @@icon" /&gt; - &lt;strong&gt;@@icon&lt;/strong&gt;
			&lt;/div&gt;
		&lt;/CapOption&gt;
	}
&lt;/CapSelect&gt;
        </code>
        </pre>

    <p>
        Final markup of the <mark>ContainerComponent</mark> should be as follows:
    </p>

    <pre data-line="11-20">
    <code class="language-csharp line-numbers">
&lt;div class="demo__container_wrapper"&gt;
    &lt;EditForm Model="@@rateContext"&gt;
        &lt;CapInput Label="Max rate" InputName="@@nameof(rateContext.MaxRate)"&gt;
            &lt;InputNumber @@bind-Value="@@rateContext.MaxRate" /&gt;
        &lt;/CapInput&gt;

        &lt;CapInput Label="Avg rate" InputName="@@nameof(rateContext.AvgRate)"&gt;
            &lt;InputNumber @@bind-Value="@@rateContext.AvgRate" /&gt;
        &lt;/CapInput&gt;

        &lt;CapSelect Label="Icon" @@bind-Value="rateContext.Icon"&gt;
            @@foreach (string icon in RateContext.Icons)
            {
                &lt;CapOption Key="@@icon" Value="@@icon"&gt;
                    &lt;div class="fa-cap-option"&gt;
                        &lt;i class="far @@icon" /&gt; - &lt;strong&gt;@@icon&lt;/strong&gt;
                    &lt;/div&gt;
                &lt;/CapOption&gt;
            }
        &lt;/CapSelect&gt;
    &lt;/EditForm&gt;

    &lt;div class="demo__container"&gt;
        @@ChildContent(rateContext)
    &lt;/div&gt;

    &lt;div class="average-rate-container"&gt;
        @@AvgRate(AverageRateContext)
    &lt;/div&gt;
&lt;/div&gt;
        </code>
        </pre>

    <p>
        Once the custom statements for class property setters were removed, inputs can be used to set any value for the properties that are binded to them with <mark>@@bind-Value="@@rateContext.&lt;PROPERTY&gt;"</mark> markup.
        To add a validation for the inputs, the <a href="https://docs.microsoft.com/en-us/aspnet/core/mvc/models/validation?view=aspnetcore-5.0#validation-attributes">build-in attributes</a> can be used.
    </p>

    <p>
        Modify the <mark>RateContext</mark> class by adding a list of validation attributes
    </p>

    <ul>
        <li>
            <mark>MaxRate</mark> property should be obligatory to provide and the value cannot be smaller that <mark>2</mark> (to show at least two rate icons to enable the user to rate).
            Use the following attributes:
            <ul>
                <li>
                    <mark>[Required]</mark>
                </li>
                <li>
                    <mark>[Range(2, int.MaxValue)]</mark>
                </li>
            </ul>
        </li>
        <li>
            <mark>AvgRate</mark> property should also be required. Value of the property is bounded by the lower possible value of the <mark>MaxRate</mark> and current value of that property.
            Use the following attributes:
            <ul>
                <li>
                    <mark>[Required]</mark>
                </li>
                <li>
                    <mark>[Range(2, int.MaxValue)]</mark>
                </li>
                <li>
                    <mark>[CompareTo(CompareToAttribute.CompareTo.LESS_THAN_OR_EQUAL, "MaxRate")]</mark>
                </li>
            </ul>
        </li>
        <li>
            <mark>Icon</mark> can be left without any kind of validation - the <mark>CapSelect</mark> component child content doesn't allow the user to select other values that ones defined with <mark>CapOption</mark>s.
        </li>
    </ul>

    <pre>
    <code class="language-csharp line-numbers">
using Capgemini.Net.Blazor.Components.Demo;
using System.ComponentModel.DataAnnotations;

namespace Capgemini.Net.Blazor.Components.Demo08.Start
{
    public class RateContext
    {
        public static readonly string[] Icons = {
            "fa-star",
            "fa-grin-stars",
            "fa-angry",
            "fa-sun"
        };

        [Required]
        [Range(2, int.MaxValue, ErrorMessage = "The field {0} must be greater than {1}.")]
        public int MaxRate { get; set; } = 6;

        [Required]
        [Range(2, int.MaxValue, ErrorMessage = "The field {0} must be greater than {1}.")]
        [CompareTo(CompareToAttribute.CompareTo.LESS_THAN_OR_EQUAL, "MaxRate")]
        public int AvgRate { get; set; } = 3;

        public string Icon { get; set; } = Icons[0];
    }
}
        </code>
        </pre>

    <p>
        List of the build-in validation attributes does not have one that can compare one property against another in other way than for equality (see <a href="https://docs.microsoft.com/en-us/dotnet/api/system.componentmodel.dataannotations.compareattribute?view=net-5.0">CompareAttribute</a>).
        <mark>CompareTo</mark> attribute is a <a href="https://docs.microsoft.com/en-us/aspnet/core/blazor/forms-validation?view=aspnetcore-5.0#custom-validation-attributes">custom</a> validation attribute defined in the <mark>Capgemini.Net.Blazor.Components.Demo</mark> namespace
        allowing to compare a given property with any other specified (one of the <mark>CompareToAttribute.CompareTo</mark> enum values can be used to define a desired relation to check).
    </p>

    <p>
        <strong>Note:</strong> <mark>[Compare]</mark> is a part of the <a href="https://docs.microsoft.com/en-us/aspnet/core/mvc/models/validation?view=aspnetcore-5.0#validation-attributes">build-in</a>
        validation attributes defined in the <mark>System.ComponentModel.DataAnnotations</mark> namespace. Not all attributes are suitable to be used for Blazor application
        if that is served as a client-side application (i.e <a href="https://docs.microsoft.com/en-us/aspnet/core/mvc/models/validation?view=aspnetcore-5.0#remote-attribute">[Remote]</a>). Blazor introduces
        its own package for validation attributes that can be used to extend the attribute-based validation capabilities (for example <mark>[Compare]</mark>
        can be replaced with the <mark>[CompareProperty]</mark> - <a href="https://www.nuget.org/packages/Microsoft.AspNetCore.Components.DataAnnotations.Validation">read more</a>).
    </p>

    <p>
        To make the <mark>EditForm</mark> recognize the validation attributes of the object type provided by the <mark>EditContext</mark> parameter (or directly through the <mark>Model</mark> property), <mark>DataAnnotationsValidator</mark> component has to be used.
        Modify the markup of the <mark>ContainerComponent</mark> to provide additional functionality:
    </p>

    <pre data-line="3, 9-11, 18-20">
    <code class="language-csharp line-numbers">
&lt;div class="demo__container_wrapper"&gt;
    &lt;EditForm Model="@@rateContext"&gt;
        &lt;DataAnnotationsValidator /&gt;

        &lt;CapInput Label="Max rate" InputName="@@nameof(rateContext.MaxRate)"&gt;
            &lt;ChildContent&gt;
                &lt;InputNumber @@bind-Value="@@rateContext.MaxRate" /&gt;
            &lt;/ChildContent&gt;
            &lt;ValidationContent&gt;
                &lt;ValidationMessage For="@@(() =&gt; @@rateContext.MaxRate)" /&gt;
            &lt;/ValidationContent&gt;
        &lt;/CapInput&gt;

        &lt;CapInput Label="Avg rate" InputName="@@nameof(rateContext.AvgRate)"&gt;
            &lt;ChildContent&gt;
                &lt;InputNumber @@bind-Value="@@rateContext.AvgRate" /&gt;
            &lt;/ChildContent&gt;
            &lt;ValidationContent&gt;
                &lt;ValidationMessage For="@@(() =&gt; @@rateContext.AvgRate)" /&gt;
            &lt;/ValidationContent&gt;
        &lt;/CapInput&gt;

        &lt;CapSelect Label="Icon" @@bind-Value="rateContext.Icon"&gt;
            @@foreach (string icon in RateContext.Icons)
            {
                &lt;CapOption Key="@@icon" Value="@@icon"&gt;
                    &lt;div class="fa-cap-option"&gt;
                        &lt;i class="far @@icon" /&gt; - &lt;strong&gt;@@icon&lt;/strong&gt;
                    &lt;/div&gt;
                &lt;/CapOption&gt;
            }
        &lt;/CapSelect&gt;
    &lt;/EditForm&gt;

    &lt;div class="demo__container"&gt;
        @@ChildContent(rateContext)
    &lt;/div&gt;

    &lt;div class="average-rate-container"&gt;
        @@AvgRate(AverageRateContext)
    &lt;/div&gt;
&lt;/div&gt;
        </code>
        </pre>

    <p>
        To make validation summary visible, <mark>ValidationSummary</mark> component can be used - <a href="https://docs.microsoft.com/en-us/aspnet/core/blazor/forms-validation?view=aspnetcore-5.0#validation-summary-and-validation-message-components">read more</a>.
    </p>

    <p>
        <mark>CapInput</mark> component is capable of receiving multiple render fragments just like the <mark>ContainerComponent</mark> itself but both of them do not provide a context values to be used -
        they are simple placeholders for:
    </p>

    <ul>
        <li>
            input (either custom or build-in component/markup i.e. <mark>&lt;InputNumber @@bind-Value="@@rateContext.MaxRate" /&gt;</mark>),
        </li>
        <li>
            validation message (either custom or build-in component/markup i.e. <mark>&lt;ValidationMessage For="@@(() =&gt; @@rateContext.MaxRate)" /&gt;</mark>),
        </li>
    </ul>

    <p>
        Of course both parameters of the <mark>RenderFragment</mark> type can accept any other markup as well.
    </p>

    <p>
        <strong>Note:</strong> without the <mark>Components.DataAnnotations.Validation</mark> package Blazor is not able to validate complex types (it provides <mark>ObjectGraphDataAnnotationsValidator</mark>
        component to make a replacement for <mark>DataAnnotationsValidator</mark> so the validation attributes like <mark>ValidateComplexType</mark> that package provides can be used).
    </p>
    };

    internal static readonly RenderFragment PointContext2 = __builder =>
    {
    <p>
        Providing invalid values for either of the <mark>Max rate</mark> or <mark>Avg rate</mark> inputs will cause the application to rise exceptions.
        Displaying validation errors with <mark>DataAnnotationsValidator</mark> or <mark>ValidationSummary</mark> won't prevent a user to input those values.
    </p>

    <p>
        Create new <mark>AvgRateInputNumber</mark> Razor component that derives from the <a href="https://docs.microsoft.com/en-us/aspnet/core/blazor/forms-validation?view=aspnetcore-5.0#built-in-forms-components">build-in</a> <mark>InputNumber&lt;TValue&gt;</mark> component (see the <a href="https://docs.microsoft.com/en-us/aspnet/core/blazor/forms-validation?view=aspnetcore-5.0#inputtext-based-on-the-input-event">example</a>):
    </p>

    <pre>
    <code class="language-csharp line-numbers">
@@typeparam TValue
@@inherits InputNumber&lt;TValue&gt;

&lt;input
    @@attributes="AdditionalAttributes"
    class="@@CssClass"
    value="@@CurrentValue"
    @@oninput="@@((value) =&gt; CurrentValueAsString = value.Value?.ToString())" /&gt;
        </code>
        </pre>

    <p>
        <mark>InputNumber&lt;TValue&gt;</mark> component which the <mark>AvgRateInputNumber</mark> <a href="https://docs.microsoft.com/en-us/aspnet/core/mvc/views/razor?view=aspnetcore-5.0#inherits">@@inherits</a> defines:
    </p>

    <ul>
        <li>
            <mark>AdditionalAttributes</mark> - a dictionary type parameter of the component that will capture all non-defined parameters for the component.
            That allows to pass through any attributes and their values down the tree of components/sub-components, making components in the tree to capture a needed subset of attributes.
            It is mainly used for <a href="https://docs.microsoft.com/en-us/aspnet/core/blazor/components/?view=aspnetcore-5.0#attribute-splatting-and-arbitrary-parameters">attributes splatting</a> to provide attributes to any non-blazor markup (like <mark>&lt;input&gt;</mark>).
        </li>
        <li>
            <mark>CssClass</mark> - a readonly property that represents the value of the <mark>class</mark> attribute that was captured by the <mark>AdditionalAttributes</mark> dictionary (i.e. <mark>&lt;ADDITIONAL CLASSES&gt;</mark>
            for the <mark>&lt;AvgRateInputNumber class="&lt;ADDITIONAL CLASSES&gt;" ... /&gt;</mark>. <strong>CSS</strong> classes defined in that way will be merged with validation-specific <strong>CSS</strong> classes
            that inherited <mark>InputNumber&lt;TValue&gt;</mark> class handles.
        </li>
        <li>
            <mark>CurrentValue</mark> - wrapper for the <mark>Value</mark> parameter of the <mark>InputNumber&lt;TValue&gt;</mark> component. On that property change, value binded to the input will be changed -
            <mark>Value</mark> will be notified of that change and <mark>@@bind-Value</mark> markup will propagate the change to it's value (i.e. <mark>VALUE</mark> for the <mark>&lt;AvgRateInputNumber @@bind-Value="&lt;VALUE&gt;" ... /&gt;</mark>).
        </li>
        <li>
            <mark>CurrentValueAsString</mark> - as it is named, the property wraps the <mark>CurrentValue</mark> and provide its <mark>string</mark> representation on get (by <mark>FormatValueAsString(CurrentValue)</mark> which
            by default is implemented as <mark>CurrentValue.ToString()</mark>) and converts the given <mark>string</mark> to the <mark>TValue</mark> type allowing the value to be assigned to the <mark>CurrentValue</mark>
            (which in turn will trigger <mark>Value</mark> parameter change and in that way the binded with <mark>@@bind-Value</mark> variable will be updated).
        </li>
    </ul>

    <p>
        <strong>Note:</strong> <mark>InputNumber&lt;TValue&gt;</mark> accepts a generic type (based on the <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.components.forms.inputnumber-1?view=aspnetcore-5.0">documentation</a> <mark>TValue</mark> can be any of the <strong>.NET</strong> numeric types).
        In order to mark the custom <mark>AdditionalAttributes</mark> Razor component as generic, <mark>@@typeparam</mark> attribute have to be used (<a href="https://docs.microsoft.com/en-us/aspnet/core/blazor/components/templated-components?view=aspnetcore-5.0#template-parameters">read more</a>).
        Attribute can be omitted as long as component inherits from the <mark>InputNumber&lt;TValue&gt;</mark> component when the generic type is fixed:
    </p>

    <div class="example-figure">
        <figure>
            <div>
                <pre data-line="1,2">
                <code class="language-csharp line-numbers">
@@typeparam TValue
@@inherits InputNumber&lt;TValue&gt;

&lt;!-- ... --&gt;
        </code>
        </pre>
            </div>
            <figcaption>
                <span>Generated class signature:</span>
                <mark>partial AvgRateInputNumber&lt;TValue&gt; : InputNumber&lt;TValue&gt;</mark>
            </figcaption>
        </figure>
        <figure>
            <div>
                <pre data-line="1">
                <code class="language-csharp line-numbers">
@@inherits InputNumber&lt;int&gt;

&lt;!-- ... --&gt;
        </code>
        </pre>
            </div>
            <figcaption>
                <span>Generated class signature:</span>
                <mark>partial AvgRateInputNumber : InputNumber&lt;int&gt;</mark>
            </figcaption>
        </figure>
    </div>

    <p>
        <mark>AvgRateInputNumber</mark> alters the default behavior of the <mark>InputNumber</mark> component to notify the <mark>EditForm</mark> component of the input change on every change - by default <mark>EditForm</mark>
        will be notified of the change only on the input's <mark>change</mark> event (i.e. after moving to the next <mark>&lt;input&gt;</mark> control - <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.components.forms.editcontext.notifyvalidationstatechanged?view=aspnetcore-5.0">read more</a>):
    </p>

    <div class="example-figure">
        <figure>
            <div>
                <Capgemini.Net.Blazor.Components.Demo.Examples.Demo08.PointContext2 Example="1" />
            </div>
            <figcaption>
                <span>default value change triggers validation on input's <mark>change</mark> event</span>
            </figcaption>
        </figure>
        <figure>
            <div>
                <Capgemini.Net.Blazor.Components.Demo.Examples.Demo08.PointContext2 Example="2" />
            </div>
            <figcaption>
                <span>custom value change triggers validation on input's <mark>input</mark> event</span>
            </figcaption>
        </figure>
    </div>

    <p>
        Update the <mark>ContainerComponent</mark> razor file with the custom <mark>AvgRateInputNumber</mark> component:
    </p>

    <pre data-line="7">
    <code class="language-csharp line-numbers">
&lt;div class="demo__container_wrapper"&gt;
    &lt;EditForm Model="@@rateContext"&gt;
        &lt;DataAnnotationsValidator /&gt;

        &lt;CapInput Label="Max rate" InputName="@@nameof(rateContext.MaxRate)"&gt;
            &lt;ChildContent&gt;
                &lt;AvgRateInputNumber @@bind-Value="@@rateContext.MaxRate" type="number" /&gt;
            &lt;/ChildContent&gt;
            &lt;ValidationContent&gt;
                &lt;ValidationMessage For="@@(() =&gt; @@rateContext.MaxRate)" /&gt;
            &lt;/ValidationContent&gt;
        &lt;/CapInput&gt;

		&lt;!-- ... --&gt;
    &lt;/EditForm&gt;

    &lt;!-- ... --&gt;
&lt;/div&gt;

        </code>
        </pre>

    <p>
        <strong>Note:</strong> <mark>type="number"</mark> attribute key-value pair will be captured by the internal <mark>AdditionalAttributes</mark> dictionary parameter. <mark>Type</mark> in a <a href="https://developer.mozilla.org/pl/docs/Web/HTML/Element/Input">valid attribute</a> for the <mark>&lt;input&gt;</mark>
        markup and it is passed with other attributes captured by this dictionary:
    </p>

    <div class="example-figure">
        <figure>
            <div>
                <Capgemini.Net.Blazor.Components.Demo.Examples.Demo08.PointContext2 Example="3" />
            </div>
            <figcaption>
                <mark>&lt;AvgRateInputNumber @@bind-Value="@@rateContext.MaxRate" /&gt;</mark>
                <span>(<mark>type="text"</mark> by default)</span>
            </figcaption>
        </figure>
        <figure>
            <div>
                <Capgemini.Net.Blazor.Components.Demo.Examples.Demo08.PointContext2 Example="4" />
            </div>
            <figcaption>
                <mark>&lt;AvgRateInputNumber @@bind-Value="@@rateContext.MaxRate" type="number" /&gt;</mark>
                <span>(enables value change on <mark>[↑]</mark> and <mark>[↓]</mark> keys)</span>
            </figcaption>
        </figure>
    </div>

    <p>
        <mark>&lt;input&gt;</mark> tag with a <mark>type="number"</mark> supports many more attributes like:
    </p>

    <ul>
        <li>
            <mark>min</mark>
        </li>
        <li>
            <mark>max</mark>
        </li>
        <li>
            <mark>step</mark>
        </li>
    </ul>

    <p>
        which can be used to make the values of those inputs to be bounded by the required properties without changing the <mark>AvgRateInputNumber</mark>/<mark>InputNumber</mark> components
        or any other that derives from <mark>InputBase</mark> (thanks to the <mark>AdditionalAttributes</mark> parameter it provides and passes all captured key-value pairs as attributes for the <mark>&lt;input&gt;</mark>).
        Modify the <mark>ContainerComponent</mark> to include those extra attributes:
    </p>

    <pre data-line="10, 22-23">
    <code class="language-csharp line-numbers">
&lt;div class="demo__container_wrapper"&gt;
    &lt;EditForm Model="@@rateContext"&gt;
        &lt;DataAnnotationsValidator /&gt;

        &lt;CapInput Label="Max rate" InputName="@@nameof(rateContext.MaxRate)"&gt;
            &lt;ChildContent&gt;
                &lt;AvgRateInputNumber
                    @@bind-Value="@@rateContext.MaxRate"
                    type="number"
                    min="@@rateContext.AvgRate /&gt;
            &lt;/ChildContent&gt;
            &lt;ValidationContent&gt;
                &lt;ValidationMessage For="@@(() =&gt; @@rateContext.MaxRate)" /&gt;
            &lt;/ValidationContent&gt;
        &lt;/CapInput&gt;

        &lt;CapInput Label="Avg rate" InputName="@@nameof(rateContext.AvgRate)"&gt;
            &lt;ChildContent&gt;
                &lt;AvgRateInputNumber
                    @@bind-Value="@@rateContext.AvgRate"
                    type="number"
                    min="2"
                    max="@@rateContext.MaxRate" /&gt;
            &lt;/ChildContent&gt;
            &lt;ValidationContent&gt;
                &lt;ValidationMessage For="@@(() =&gt; @@rateContext.AvgRate)" /&gt;
            &lt;/ValidationContent&gt;
        &lt;/CapInput&gt;

        &lt;CapSelect Label="Icon" @@bind-Value="rateContext.Icon"&gt;
            @@foreach (string icon in RateContext.Icons)
            {
                &lt;CapOption Key="@@icon" Value="@@icon"&gt;
                    &lt;div class="fa-cap-option"&gt;
                        &lt;i class="far @@icon" /&gt; - &lt;strong&gt;@@icon&lt;/strong&gt;
                    &lt;/div&gt;
                &lt;/CapOption&gt;
            }
        &lt;/CapSelect&gt;
    &lt;/EditForm&gt;

    &lt;div class="demo__container"&gt;
        @@ChildContent(rateContext)
    &lt;/div&gt;

    &lt;div class="average-rate-container"&gt;
        @@AvgRate(AverageRateContext)
    &lt;/div&gt;
&lt;/div&gt;

        </code>
        </pre>

    <p>
        <strong>Note:</strong> usage of <a href="https://docs.microsoft.com/en-us/aspnet/core/blazor/components/?view=aspnetcore-5.0#attribute-splatting-and-arbitrary-parameters">attribute splatting</a> is not recommended
        from the performance perspective. Care must be taken if a parameter marked with <mark>[Parameter(CaptureUnmatchedValues = true)]</mark> is used for a components with multiple instances in the application (i.e. rendered by a loop) - <a href="https://docs.microsoft.com/en-us/aspnet/core/blazor/webassembly-performance-best-practices?view=aspnetcore-5.0#avoid-attribute-splatting-with-captureunmatchedvalues">read more</a>.
    </p>

    <p>
        <strong>Note:</strong> position of the <mark>@@attributes="AdditionalAttributes"</mark> attribute matters. By default when <mark>@@attributes</mark> are splatted on the element,
        the attributes are processed from right to left (<a href="https://docs.microsoft.com/en-us/aspnet/core/blazor/components/?view=aspnetcore-5.0#attribute-splatting-and-arbitrary-parameters">read more</a>).
    </p>
    };

    internal static readonly RenderFragment PointContext3 = __builder =>
    {
    <p>
        Although either of <mark>AvgRateInputNumber</mark> inputs aren't allowed the invalid values to be selected, changing value of one input (which will change the value
        of the <mark>max</mark> attribute of the other input) can still generate an invalid state of the application when ones input values is no longer valid. To fix that
        values of both inputs has to be connected to each other.
    </p>

    <p>
        Create the <mark>./Start/MaxRateInputNumber.razor</mark> file with the given content:
    </p>

    <pre data-line="2, 13, 17-18, 22-26, 31">
    <code class="language-csharp line-numbers">
@@typeparam TValue
@@inherits RateInputNumberBase&lt;TValue&gt;
@@implements IDisposable

&lt;input @@attributes="AdditionalAttributes"
       class="@@CssClass"
       value="@@CurrentValue"
       @@oninput="@@((value) =&gt; CurrentValueAsString = value.Value?.ToString())" /&gt;

@@code {
    protected override void OnInitialized()
    {
        EditContext.OnFieldChanged += HandleFieldChanged;
        base.OnInitialized();
    }

    private void HandleFieldChanged(object? sender, FieldChangedEventArgs e)
        =&gt; OnSelectedFieldChanged&lt;RateContext&gt;(nameof(RateContext.AvgRate), e, UpdateField);

    private void UpdateField(RateContext model, FieldIdentifier fieldIdentifier)
    {
        if (model.MaxRate &lt; model.AvgRate)
        {
            CurrentValueAsString = model.AvgRate.ToString();
            EditContext.Validate();
        }
    }

    public void Dispose()
    {
        EditContext.OnFieldChanged -= HandleFieldChanged;
    }
}
        </code>
        </pre>

    <ul>
        <li>
            The component inherits from the <mark>RateInputNumberBase&lt;TValue&gt;</mark> class (line <mark>2</mark>). The class provides
            the <mark>OnSelectedFieldChanged&lt;T&gt;(string fieldName, FieldChangedEventArgs args, Action&lt;T, FieldIdentifier&gt; action)</mark> method which will trigger an <mark>action</mark>
            whenever a value of the <mark>fieldName</mark> input changed.
        </li>
        <li>
            <mark>EditForm</mark> component that wraps inputs for <mark>MaxRate</mark>, <mark>AvgRate</mark> and <mark>Icon</mark> provides a <mark>EditContext</mark> object for all of them:

            <pre>
            <code class="language-csharp line-numbers">
&lt;!-- ... --&gt;

&lt;EditForm Model="@@rateContext"&gt;
	&lt;!-- ... --&gt;
&lt;/EditForm&gt;

&lt;!-- ... --&gt;
                    </code>
                </pre>

            This object is shared across all inputs inside (<mark>EditContext</mark> built upon <mark>Model="@@rateContext"</mark> is shared using <mark>AdditionalAttributes</mark> component internally
            like so: <mark>&lt;CascadingValue IsFixed="true" Value="_editContext"&gt;</mark>). Line <mark>13</mark> is using one of the <mark>EditContext</mark>'s events to make a subscription
            for any input value change (<a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.components.forms.editcontext.onfieldchanged?view=aspnetcore-5.0">read more</a>).
        </li>
        <li>
            With <mark>OnFieldChanged</mark> callback raised, method called by the <mark>HandleFieldChanged</mark> (lines <mark>17-18</mark>) makes the <mark>UpdateField</mark> method to be executed in the event of
            the <mark>RateContext.AvgRate</mark> property changed (<mark>OnFieldChanged</mark> is called upon any input value change but <mark>OnSelectedFieldChanged</mark> filters those calls
            and passes through only the callbacks triggered by the <mark>RateContext.AvgRate</mark> input).
        </li>
        <li>
            If the <mark>AvgRate</mark> change would result in <mark>AvgRate</mark> to be greater than <mark>MaxRate</mark> (which would make the <mark>AvgRate</mark> value invalid, resulting in throwing an exception),
            input's value for <mark>MaxRate</mark> will be updated to be the same as <mark>AvgRate</mark> (lines <mark>22-26</mark>). Then the validation will be triggered (otherwise the validation triggered by the <mark>[CompareTo(CompareToAttribute.CompareTo.LESS_THAN_OR_EQUAL, "MaxRate")]</mark>
            before the <mark>MaxRate</mark> had a chance to be updated won't be overwritten).
        </li>
        <li>
            On component destruction any subscription done to the <mark>OnFieldChanged</mark> event has to be disposed gracefully (line <mark>31</mark>) - <a href="https://docs.microsoft.com/en-us/aspnet/core/blazor/components/lifecycle?view=aspnetcore-5.0#component-disposal-with-idisposable">read more</a>.
        </li>
    </ul>

    <p>
        Replace the content for the other input custom component - <mark>AvgRateInputNumber</mark>. Add same <mark>@@code {}</mark> block as <mark>MaxRateInputNumber</mark> has
        (changing the filed name to listen to: from <mark>nameof(RateContext.AvgRate)</mark> to <mark>nameof(RateContext.MaxRate)</mark> and the property to be assigned to the <mark>CurrentValueAsString</mark>):
    </p>

    <pre data-line="18, 24">
    <code class="language-csharp line-numbers">
@@typeparam TValue
@@inherits RateInputNumberBase&lt;TValue&gt;
@@implements IDisposable

&lt;input @@attributes="AdditionalAttributes"
       class="@@CssClass"
       value="@@CurrentValue"
       @@oninput="@@((value) =&gt; CurrentValueAsString = value.Value?.ToString())" /&gt;

@@code {
    protected override void OnInitialized()
    {
        EditContext.OnFieldChanged += HandleFieldChanged;
        base.OnInitialized();
    }

    private void HandleFieldChanged(object? sender, FieldChangedEventArgs e)
        =&gt; OnSelectedFieldChanged&lt;RateContext&gt;(<mark>nameof(RateContext.MaxRate)</mark>, e, UpdateField);

    private void UpdateField(RateContext model, FieldIdentifier fieldIdentifier)
    {
        if (model.MaxRate &lt; model.AvgRate)
        {
            CurrentValueAsString = model.<mark>MaxRate</mark>.ToString();
            EditContext.Validate();
        }
    }

    public void Dispose()
    {
        EditContext.OnFieldChanged -= HandleFieldChanged;
    }
}
        </code>
        </pre>

    <p>
        Remove the <mark>min</mark> and <mark>max</mark> boundaries for both input components from the <mark>ContainerComponent</mark> (except for the default <mark>min="2"</mark>). 
        Replace the <mark>AvgRateInputNumber</mark> component for the <mark>Max rate</mark> input:
    </p>

    <pre data-line="7-10, 19-22">
    <code class="language-csharp line-numbers">
&lt;div class="demo__container_wrapper"&gt;
    &lt;EditForm Model="@@rateContext"&gt;
        &lt;DataAnnotationsValidator /&gt;

        &lt;CapInput Label="Max rate" InputName="@@nameof(rateContext.MaxRate)"&gt;
            &lt;ChildContent&gt;
                &lt;<mark>MaxRateInputNumber</mark>
                    @@bind-Value="@@rateContext.MaxRate"
                    type="number"
                    min="2" /&gt;
            &lt;/ChildContent&gt;
            &lt;ValidationContent&gt;
                &lt;ValidationMessage For="@@(() =&gt; @@rateContext.MaxRate)" /&gt;
            &lt;/ValidationContent&gt;
        &lt;/CapInput&gt;

        &lt;CapInput Label="Avg rate" InputName="@@nameof(rateContext.AvgRate)"&gt;
            &lt;ChildContent&gt;
                &lt;AvgRateInputNumber
                    @@bind-Value="@@rateContext.AvgRate"
                    type="number"
                    min="2" /&gt;
            &lt;/ChildContent&gt;
            &lt;ValidationContent&gt;
                &lt;ValidationMessage For="@@(() =&gt; @@rateContext.AvgRate)" /&gt;
            &lt;/ValidationContent&gt;
        &lt;/CapInput&gt;

        &lt;CapSelect Label="Icon" @@bind-Value="rateContext.Icon"&gt;
            @@foreach (string icon in RateContext.Icons)
            {
                &lt;CapOption Key="@@icon" Value="@@icon"&gt;
                    &lt;div class="fa-cap-option"&gt;
                        &lt;i class="far @@icon" /&gt; - &lt;strong&gt;@@icon&lt;/strong&gt;
                    &lt;/div&gt;
                &lt;/CapOption&gt;
            }
        &lt;/CapSelect&gt;
    &lt;/EditForm&gt;

    &lt;div class="demo__container"&gt;
        @@ChildContent(rateContext)
    &lt;/div&gt;

    &lt;div class="average-rate-container"&gt;
        @@AvgRate(AverageRateContext)
    &lt;/div&gt;
&lt;/div&gt;

        </code>
        </pre>

    <p>
        <strong>Note:</strong> both <mark>@@code {}</mark> blocks for <mark>AvgRateInputNumber</mark> and <mark>MaxRateInputNumber</mark> can be simplified with the <mark>Capgemini.Net.Blazor.Components.Demo.RateInputNumberAbstractBase</mark> class.
        See final <mark>AvgRateInputNumber</mark> and <mark>MaxRateInputNumber</mark> code:
    </p>

    <pre>
    <code class="language-csharp line-numbers">
@@typeparam TValue
@@inherits RateInputNumberAbstractBase&lt;TValue&gt;
@@implements IDisposable

&lt;input @@attributes="AdditionalAttributes"
       class="@@CssClass"
       value="@@CurrentValue"
       @@oninput="@@((value) =&gt; CurrentValueAsString = value.Value?.ToString())" /&gt;

@@code {
    protected override void HandleFieldChanged(object? sender, FieldChangedEventArgs e)
        =&gt; OnSelectedFieldChanged&lt;RateContext&gt;(nameof(RateContext.MaxRate), e, UpdateField);

    private void UpdateField(RateContext model, FieldIdentifier fieldIdentifier)
    {
        if (model.MaxRate &lt; model.AvgRate)
        {
            CurrentValueAsString = model.MaxRate.ToString();
            EditContext.Validate();
        }
    }
}
        </code>
        </pre>

    <pre>
    <code class="language-csharp line-numbers">
@@typeparam TValue
@@inherits RateInputNumberAbstractBase&lt;TValue&gt;
@@implements IDisposable

&lt;input @@attributes="AdditionalAttributes"
       class="@@CssClass"
       value="@@CurrentValue"
       @@oninput="@@((value) =&gt; CurrentValueAsString = value.Value?.ToString())" /&gt;

@@code {
    protected override void HandleFieldChanged(object? sender, FieldChangedEventArgs e)
        =&gt; OnSelectedFieldChanged&lt;RateContext&gt;(nameof(RateContext.AvgRate), e, UpdateField);

    private void UpdateField(RateContext model, FieldIdentifier fieldIdentifier)
    {
        if (model.MaxRate &lt; model.AvgRate)
        {
            CurrentValueAsString = model.AvgRate.ToString();
            EditContext.Validate();
        }
    }
}
        </code>
        </pre>
    };

    internal static readonly RenderFragment PointContext4 = __builder =>
    {
<p>
    Both <mark>MaxRateInputNumber</mark> and <mark>AvgRateInputNumber</mark> values can still be set to invalid values as by default <mark>min</mark>, <mark>max</mark> and <mark>step</mark> attributes
    only works if the value is selected by any of the arrow keys (<mark>[↑]</mark> and <mark>[↓]</mark>). Those parameters don't work if a user changes the value of the input in the other way (i.e. by deleting the content of the input
    and type a new value manually).
</p>

    <p>
        Create a new base class for <mark>MaxRateInputNumber</mark> and <mark>AvgRateInputNumber</mark> components - <mark>RateInputMinMaxNumberAbstractBase</mark>:
    </p>

    <pre data-line="10-11, 13-14, 27-35">
    <code class="language-csharp line-numbers">
using Capgemini.Net.Blazor.Components.Demo;
using Microsoft.AspNetCore.Components;
using System;
using System.Diagnostics.CodeAnalysis;

namespace Capgemini.Net.Blazor.Components.Demo08.Start
{
    public abstract class RateInputMinMaxNumberAbstractBase&lt;TValue&gt; : RateInputNumberAbstractBase&lt;TValue&gt;
    {
        [Parameter]
        public TValue Min { get; set; } = default!;

        [Parameter]
        public TValue Max { get; set; } = default!;

        protected override bool TryParseValueFromString(
            string? value,
            [MaybeNullWhen(false)] out TValue result,
            [NotNullWhen(false)] out string? validationErrorMessage)
        {
            if (base.TryParseValueFromString(value, out result, out validationErrorMessage))
            {
                IComparable&lt;TValue&gt;? selfValueComparer = result as IComparable&lt;TValue&gt;;

                if (selfValueComparer is not null)
                {
                    if (Min is not null && selfValueComparer.CompareTo(Min) &lt; 0)
                    {
                        result = Min;
                    }

                    if (Max is not null && selfValueComparer.CompareTo(Max) &gt; 0)
                    {
                        result = Max;
                    }
                }

                return true;
            }

            return false;
        }
    }
}
        </code>
        </pre>

    <p>
        <mark>RateInputMinMaxNumberAbstractBase</mark> class adds custom parameters for <mark>Min</mark> and <mark>Max</mark> (lines <mark>10-14</mark>. Those parameters will be used to replace the default <mark>min</mark>, <mark>max</mark>
        attributes for the <mark>&lt;input&gt;</mark> components that were used.
    </p>

    <p>
        The class overwrites the <mark>TryParseValueFromString</mark> method which is used by the <mark>InputBase&lt;TValue&gt;</mark> to update the <mark>CurrentValue</mark> (of type <mark>TValue</mark>) if the
        <mark>CurrentValueAsString</mark> is updated - like on the <mark>input</mark> event in line <mark>10</mark>:
    </p>

    <pre data-line="10">
    <code class="language-csharp line-numbers">
@@typeparam TValue
@@inherits RateInputNumberAbstractBase&lt;TValue&gt;
@@implements IDisposable

&lt;!-- ... --&gt;

&lt;input @@attributes="AdditionalAttributes"
       class="@@CssClass"
       value="@@CurrentValue"
       @@oninput="@@((value) =&gt; <mark>CurrentValueAsString = value.Value?.ToString())</mark>" /&gt;

@@code {
	// ...
}
        </code>
        </pre>

    <p>
        It handles the conversion to the <mark>TValue</mark> type and returns it by the <mark>result</mark> output parameter. By adding a custom logic this value can be forced
        to not extend any of the <mark>Min</mark> or <mark>Max</mark> parameters (lines <mark>27-35</mark>).
    </p>

    <p>
        Replace the class that both <mark>MaxRateInputNumber</mark> and <mark>AvgRateInputNumber</mark> inherits from <mark>RateInputNumberAbstractBase</mark> to the <mark>RateInputMinMaxNumberAbstractBase</mark> abstract class:
    </p>

    <pre data-line="2">
    <code class="language-csharp line-numbers">
@@typeparam TValue
@@inherits <mark>RateInputMinMaxNumberAbstractBase</mark>&lt;TValue&gt;
@@implements IDisposable

&lt;!-- ... --&gt;

&lt;input @@attributes="AdditionalAttributes"
       class="@@CssClass"
       value="@@CurrentValue"
       @@oninput="@@((value) =&gt; CurrentValueAsString = value.Value?.ToString())" /&gt;

@@code {
	// ...
}
        </code>
        </pre>

    <p>
        Update the markup of the <mark>ContainerComponent</mark> to use <mark>Min</mark>, <mark>Max</mark> parameters provided by the new base class:
    </p>

    <pre data-line="9-10, 22-23">
    <code class="language-csharp line-numbers">
&lt;div class="demo__container_wrapper"&gt;
    &lt;EditForm Model="@@rateContext"&gt;
        &lt;DataAnnotationsValidator /&gt;

        &lt;CapInput Label="Max rate" InputName="@@nameof(rateContext.MaxRate)"&gt;
            &lt;ChildContent&gt;
                &lt;MaxRateInputNumber
                    @@bind-Value="@@rateContext.MaxRate"
                    Min="@@rateContext.AvgRate"
                    Max="@@int.MaxValue"
                    type="number" /&gt;
            &lt;/ChildContent&gt;
            &lt;ValidationContent&gt;
                &lt;ValidationMessage For="@@(() =&gt; @@rateContext.MaxRate)" /&gt;
            &lt;/ValidationContent&gt;
        &lt;/CapInput&gt;

        &lt;CapInput Label="Avg rate" InputName="@@nameof(rateContext.AvgRate)"&gt;
            &lt;ChildContent&gt;
                &lt;AvgRateInputNumber
                    @@bind-Value="@@rateContext.AvgRate"
                    Min="2"
                    Max="@@rateContext.MaxRate"
                    type="number" /&gt;
            &lt;/ChildContent&gt;
            &lt;ValidationContent&gt;
                &lt;ValidationMessage For="@@(() =&gt; @@rateContext.AvgRate)" /&gt;
            &lt;/ValidationContent&gt;
        &lt;/CapInput&gt;

        &lt;CapSelect Label="Icon" @@bind-Value="rateContext.Icon"&gt;
            @@foreach (string icon in RateContext.Icons)
            {
                &lt;CapOption Key="@@icon" Value="@@icon"&gt;
                    &lt;div class="fa-cap-option"&gt;
                        &lt;i class="far @@icon" /&gt; - &lt;strong&gt;@@icon&lt;/strong&gt;
                    &lt;/div&gt;
                &lt;/CapOption&gt;
            }
        &lt;/CapSelect&gt;
    &lt;/EditForm&gt;

    &lt;div class="demo__container"&gt;
        @@ChildContent(rateContext)
    &lt;/div&gt;

    &lt;div class="average-rate-container"&gt;
        @@AvgRate(AverageRateContext)
    &lt;/div&gt;
&lt;/div&gt;
        </code>
        </pre>

    <p>
        Finally update the markup of both <mark>MaxRateInputNumber</mark> and <mark>AvgRateInputNumber</mark> components. Replace the <mark>value</mark> attribute and the <mark>@@oninput</mark> directive:
    </p>

    <pre data-line="8">
    <code class="language-csharp line-numbers">
@@typeparam TValue
@@inherits RateInputMinMaxNumberAbstractBase&lt;TValue&gt;
@@implements IDisposable

&lt;input @@attributes="AdditionalAttributes"
       class="@@CssClass"
       value="@@CurrentValue"
       @@oninput="@@((value) =&gt; CurrentValueAsString = value.Value?.ToString())" /&gt;

@@code {
	// ...
}
        </code>
        </pre>

    <pre data-line="7-8">
    <code class="language-csharp line-numbers">
@@typeparam TValue
@@inherits RateInputMinMaxNumberAbstractBase&lt;TValue&gt;
@@implements IDisposable

&lt;input @@attributes="AdditionalAttributes"
       class="@@CssClass"
       @@bind-value="@@CurrentValueAsString"
       @@bind-value:event="oninput" /&gt;

@@code {
    protected override void HandleFieldChanged(object? sender, FieldChangedEventArgs e)
        =&gt; OnSelectedFieldChanged&lt;RateContext&gt;(nameof(RateContext.AvgRate), e, UpdateField);

    private void UpdateField(RateContext model, FieldIdentifier fieldIdentifier)
    {
        if (model.MaxRate &lt; model.AvgRate)
        {
            CurrentValueAsString = model.AvgRate.ToString();
            EditContext.Validate();
        }
    }
}
        </code>
        </pre>

    <pre data-line="7-8">
    <code class="language-csharp line-numbers">
@@typeparam TValue
@@inherits RateInputMinMaxNumberAbstractBase&lt;TValue&gt;
@@implements IDisposable

&lt;input @@attributes="AdditionalAttributes"
       class="@@CssClass"
       @@bind-value="@@CurrentValueAsString"
       @@bind-value:event="oninput" /&gt;

@@code {
    protected override void HandleFieldChanged(object? sender, FieldChangedEventArgs e)
        =&gt; OnSelectedFieldChanged&lt;RateContext&gt;(nameof(RateContext.MaxRate), e, UpdateField);

    private void UpdateField(RateContext model, FieldIdentifier fieldIdentifier)
    {
        if (model.MaxRate &lt; model.AvgRate)
        {
            CurrentValueAsString = model.MaxRate.ToString();
            EditContext.Validate();
        }
    }
}
        </code>
        </pre>

    <p>
        In place of the deleted markup, the <mark>@@bind-value</mark> was used. By default it is a shorthand for the given markup (<a href="https://docs.microsoft.com/en-us/aspnet/core/blazor/components/data-binding?view=aspnetcore-5.0">read more</a>):
    </p>

    <pre data-line="7-9">
    <code class="language-csharp line-numbers">
@@typeparam TValue
@@inherits RateInputMinMaxNumberAbstractBase&lt;TValue&gt;
@@implements IDisposable

&lt;input @@attributes="AdditionalAttributes"
       class="@@CssClass"
       value="@@CurrentValueAsString"
       @@onchange="@@((ChangeEventArgs __e) =&gt; CurrentValueAsString = 
			__e.Value.ToString())" /&gt;

@@code {
	// ...
}
        </code>
        </pre>

    <p>
        By using a <a href="https://docs.microsoft.com/en-us/aspnet/core/blazor/components/?view=aspnetcore-5.0#razor-syntax">directive attribute</a> <mark>@@bind-value:event="oninput"</mark>
        the default event for the binding can be changed. By default that event is <mark>onchange</mark>. With the event changed, the equivalent markup would be like this:
    </p>

    <pre data-line="7-9">
    <code class="language-csharp line-numbers">
@@typeparam TValue
@@inherits RateInputMinMaxNumberAbstractBase&lt;TValue&gt;
@@implements IDisposable

&lt;input @@attributes="AdditionalAttributes"
       class="@@CssClass"
       value="@@CurrentValueAsString"
       @@oninput="@@((ChangeEventArgs __e) =&gt; CurrentValueAsString = 
			__e.Value.ToString())" /&gt;

@@code {
	// ...
}
        </code>
        </pre>

        <p>
            and the new value will be assigned to the <mark>CurrentValueAsString</mark> variable on every input's change (not only on input's blur).
        </p>

        <p>
            Directive attributes can also control other aspects of the event like
        </p>

        <ul>
            <li>
                <mark>@@on{EVENT}:preventDefault</mark> - to prevent a default <mark>{EVENT}</mark> behavior (<a href="https://docs.microsoft.com/en-us/aspnet/core/blazor/components/event-handling?view=aspnetcore-5.0#prevent-default-actions">see example</a>),
            </li>
            <li>
                <mark>@@on{EVENT}:stopPropagation</mark> - to prevent the <mark>{EVENT}</mark> to be propagated (<a href="https://docs.microsoft.com/en-us/aspnet/core/blazor/components/event-handling?view=aspnetcore-5.0#stop-event-propagation">see example</a>).
            </li>
        </ul>

        <p>
            <strong>Note:</strong> by providing values for both <mark>Min</mark> and <mark>Max</mark> parameters, field values no longer be updated on other field's value change (i.e. <mark>Max rate</mark> won't be 
            changed alongside with the <mark>Avg rate</mark> if the last one would be increased in the way it's value would be greater than <mark>Max rate</mark> - <mark>Max="@@rateContext.MaxRate"</mark> used to bound the value of the 
            <mark>AvgRateInputNumber</mark> will prevent the scenario from happening).
        </p>
    };
}