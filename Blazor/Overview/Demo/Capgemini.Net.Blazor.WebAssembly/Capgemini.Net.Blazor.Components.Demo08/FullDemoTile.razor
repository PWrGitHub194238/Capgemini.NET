<Title Value=".NET Community Blazor Introduction | Demo 8"></Title>

@if (Context is not null)
{
    <FullTileContainer ChecklistContext="@Context">
        <DemoStartPoint>
            <Capgemini.Net.Blazor.Components.Demo08.Start.WrapperComponent />
        </DemoStartPoint>
        <DemoEndPoint>
            <Capgemini.Net.Blazor.Components.Demo08.End.WrapperComponent />
        </DemoEndPoint>
    </FullTileContainer>
}


@code {
    private static readonly string BUILD_IN_ATTRIBUTES = "https://docs.microsoft.com/en-us/aspnet/core/mvc/models/validation?view=aspnetcore-5.0#validation-attributes";
    private static readonly string COMPARE_ATTRIBUTE = "https://docs.microsoft.com/en-us/dotnet/api/system.componentmodel.dataannotations.compareattribute?view=net-5.0";
    private static readonly string CUSTOM = "https://docs.microsoft.com/en-us/aspnet/core/blazor/forms-validation?view=aspnetcore-5.0#custom-validation-attributes";
    private static readonly string BUILD_IN = "https://docs.microsoft.com/en-us/aspnet/core/mvc/models/validation?view=aspnetcore-5.0#validation-attribute";
    private static readonly string REMOTE = "https://docs.microsoft.com/en-us/aspnet/core/mvc/models/validation?view=aspnetcore-5.0#remote-attribute";
    private static readonly string READ_MORE_1 = "https://www.nuget.org/packages/Microsoft.AspNetCore.Components.DataAnnotations.Validation";
    private static readonly string READ_MORE_2 = "https://docs.microsoft.com/en-us/aspnet/core/blazor/forms-validation?view=aspnetcore-5.0#validation-summary-and-validation-message-components";

    internal static readonly RenderFragment PointContext1 = __builder =>
    {
        <p>
            Replace all custom properties of the <mark>./Start/RateContext.cs</mark> file with auto-generated properties. 
            Preserve default values from private fields (<mark>maxRate = 6</mark> and <mark>avgRate = 3</mark>):
        </p>

        <pre data-line="12, 14, 16">
            <code class="language-csharp line-numbers">
namespace Capgemini.Net.Blazor.Components.Demo08.Start
{
    public class RateContext
    {
        public static readonly string[] Icons = {
            "fa-star",
            "fa-grin-stars",
            "fa-angry",
            "fa-sun"
        };

        public int MaxRate { get; set; } = 6;

        public int AvgRate { get; set; } = 3;

        public string Icon { get; set; } = Icons[0];
    }
}
            </code>
        </pre>

        <p>
            <strong>Note:</strong> as the <mark>CapSelect</mark> component was used to render the drop-down list 
            for the <mark>Icons</mark> array, there is also no need to keep the <mark>IconIndex</mark> property 
            with its custom setter (<mark>CapSelect</mark> renders its options through the 
            <mark>@@for (int i = 0; i &lt; RateContext.Icons.Length; i += 1)</mark> loop).
        </p>

        <p>
            Simplify the markup of the <mark>ContainerComponent.razor</mark> file to make the <mark>CapSelect</mark> component 
            to work directly with the <strong>Font Awesome</strong>'s <strong>CSS</strong> classes provided by the 
            <mark>RateContext.Icons</mark>. As the component no longer needs to handle converting index value 
            of the <mark>Icons</mark> array to one of its value with the delegate 
            (<mark>ParseValue="@@((option) =&gt; RateContext.Icons[option])"&gt;</mark>)
            that parameter can be removed and the entire loop simplified:
        </p>

        <pre data-line="11-20">
            <code class="language-csharp line-numbers">
&lt;div class="demo__container_wrapper"&gt;
    &lt;EditForm Model="@@rateContext"&gt;
        &lt;CapInput Label="Max rate" InputName="@@nameof(rateContext.MaxRate)"&gt;
            &lt;InputNumber @@bind-Value="@@rateContext.MaxRate" /&gt;
        &lt;/CapInput&gt;

        &lt;CapInput Label="Avg rate" InputName="@@nameof(rateContext.AvgRate)"&gt;
            &lt;InputNumber @@bind-Value="@@rateContext.AvgRate" /&gt;
        &lt;/CapInput&gt;

        &lt;CapSelect Label="Icon" @@bind-Value="rateContext.Icon"&gt;
            @@foreach (string icon in RateContext.Icons)
            {
                &lt;CapOption Key="@@icon" Value="@@icon"&gt;
                    &lt;div class="fa-cap-option"&gt;
                        &lt;i class="far @@icon" /&gt; - &lt;strong&gt;@@icon&lt;/strong&gt;
                    &lt;/div&gt;
                &lt;/CapOption&gt;
            }
        &lt;/CapSelect&gt;
    &lt;/EditForm&gt;

    &lt;div class="demo__container"&gt;
        @@ChildContent(rateContext)
    &lt;/div&gt;

    &lt;div class="average-rate-container"&gt;
        @@AvgRate(AverageRateContext)
    &lt;/div&gt;
&lt;/div&gt;
            </code>
        </pre>

        <p>
            Once the custom statements for class property setters were removed, inputs can be used to set any value 
            for the properties that are binded to them with <mark>@@bind-Value="@@rateContext.&lt;PROPERTY&gt;"</mark> markup.
            To add a validation for the inputs, the <a href="@BUILD_IN_ATTRIBUTES">build-in attributes</a> can be used.
        </p>

        <p>
            Modify the <mark>RateContext</mark> class by adding a list of validation attributes
        </p>

        <ul>
            <li>
                <mark>MaxRate</mark> property should be obligatory and the value cannot be smaller that <mark>2</mark> (to show 
                at least two rate icons, to enable the user to rate).
                Use the following attributes:
                <ul>
                    <li>
                        <mark>[Required]</mark>
                    </li>
                    <li>
                        <mark>[Range(2, int.MaxValue)]</mark>
                    </li>
                </ul>
            </li>
            <li>
                <mark>AvgRate</mark> property should also be required. Value of the property is bounded by the lower possible value 
                of the <mark>MaxRate</mark> input and current value of that property.
                Use the following attributes:
                <ul>
                    <li>
                        <mark>[Required]</mark>
                    </li>
                    <li>
                        <mark>[Range(2, int.MaxValue)]</mark>
                    </li>
                    <li>
                        <mark>[CompareTo(CompareToAttribute.CompareTo.LESS_THAN_OR_EQUAL, "MaxRate")]</mark>
                    </li>
                </ul>
            </li>
            <li>
                <mark>Icon</mark> can be left without any kind of validation - the <mark>CapSelect</mark> component child's content 
                doesn't allow the user to select other values that those defined with <mark>CapOption</mark> components.
            </li>
        </ul>

        <pre data-line="15-16, 19-21">
            <code class="language-csharp line-numbers">
using Capgemini.Net.Blazor.Components.Demo;
using System.ComponentModel.DataAnnotations;

namespace Capgemini.Net.Blazor.Components.Demo08.Start
{
    public class RateContext
    {
        public static readonly string[] Icons = {
            "fa-star",
            "fa-grin-stars",
            "fa-angry",
            "fa-sun"
        };

        [Required]
        [Range(2, int.MaxValue, ErrorMessage = "The field {0} must be greater than {1}.")]
        public int MaxRate { get; set; } = 6;

        [Required]
        [Range(2, int.MaxValue, ErrorMessage = "The field {0} must be greater than {1}.")]
        [CompareTo(CompareToAttribute.CompareTo.LESS_THAN_OR_EQUAL, "MaxRate")]
        public int AvgRate { get; set; } = 3;

        public string Icon { get; set; } = Icons[0];
    }
}
            </code>
        </pre>

        <p>
            List of the build-in validation attributes does not have one that can compare one property against another 
            in other way than for equality (see <a href="@COMPARE_ATTRIBUTE">CompareAttribute</a>).
            <mark>CompareTo</mark> attribute is a <a href="@CUSTOM">custom</a> validation attribute defined 
            in the <mark>Capgemini.Net.Blazor.Components.Demo</mark> namespace,
            allowing to compare a given property with any other specified (one of the <mark>CompareToAttribute.CompareTo</mark> 
            enum values can be used to define a desired relation to check).
        </p>

        <p>
            <strong>Note:</strong> <mark>[Compare]</mark> is a part of the <a href="@BUILD_IN">build-in</a>
            validation attributes defined in the <mark>System.ComponentModel.DataAnnotations</mark> namespace. Not all attributes 
            are suitable to be used for Blazor application (i.e <a href="@REMOTE">[Remote]</a>). Blazor introduces
            its own package for validation purposes that can be used to extend the attribute-based validation capabilities (for example 
            <mark>[Compare]</mark> can be replaced with the <mark>[CompareProperty]</mark> - <a href="@READ_MORE_1">read more</a>).
        </p>

        <p>
            To make the <mark>EditForm</mark> recognize the validation attributes of the object type provided 
            by the <mark>EditContext</mark> parameter (or directly through the <mark>Model</mark> property), 
            <mark>DataAnnotationsValidator</mark> component has to be used.
            Modify the markup of the <mark>ContainerComponent</mark> to provide additional functionality:
        </p>

        <pre data-line="3, 6, 8, 9-11, 15, 17, 18-20">
            <code class="language-csharp line-numbers">
&lt;div class="demo__container_wrapper"&gt;
    &lt;EditForm Model="@@rateContext"&gt;
        &lt;DataAnnotationsValidator /&gt;

        &lt;CapInput Label="Max rate" InputName="@@nameof(rateContext.MaxRate)"&gt;
            &lt;ChildContent&gt;
                &lt;InputNumber @@bind-Value="@@rateContext.MaxRate" /&gt;
            &lt;/ChildContent&gt;
            &lt;ValidationContent&gt;
                &lt;ValidationMessage For="@@(() =&gt; @@rateContext.MaxRate)" /&gt;
            &lt;/ValidationContent&gt;
        &lt;/CapInput&gt;

        &lt;CapInput Label="Avg rate" InputName="@@nameof(rateContext.AvgRate)"&gt;
            &lt;ChildContent&gt;
                &lt;InputNumber @@bind-Value="@@rateContext.AvgRate" /&gt;
            &lt;/ChildContent&gt;
            &lt;ValidationContent&gt;
                &lt;ValidationMessage For="@@(() =&gt; @@rateContext.AvgRate)" /&gt;
            &lt;/ValidationContent&gt;
        &lt;/CapInput&gt;

        &lt;CapSelect Label="Icon" @@bind-Value="rateContext.Icon"&gt;
            @@foreach (string icon in RateContext.Icons)
            {
                &lt;CapOption Key="@@icon" Value="@@icon"&gt;
                    &lt;div class="fa-cap-option"&gt;
                        &lt;i class="far @@icon" /&gt; - &lt;strong&gt;@@icon&lt;/strong&gt;
                    &lt;/div&gt;
                &lt;/CapOption&gt;
            }
        &lt;/CapSelect&gt;
    &lt;/EditForm&gt;

    &lt;div class="demo__container"&gt;
        @@ChildContent(rateContext)
    &lt;/div&gt;

    &lt;div class="average-rate-container"&gt;
        @@AvgRate(AverageRateContext)
    &lt;/div&gt;
&lt;/div&gt;
            </code>
        </pre>

        <p>
            <strong>Note:</strong> to make validation summary visible, <mark>ValidationSummary</mark> component 
            can be used - <a href="@READ_MORE_2">read more</a>.
        </p>

        <p>
            <mark>CapInput</mark> component is capable of receiving multiple render fragments, just like the <mark>ContainerComponent</mark>.
            Both <mark>&lt;ChildContent&gt;</mark> and <mark>&lt;ValidationContent&gt;</mark> do not provide a context values to be used -
            they are simple placeholders for:
        </p>

        <ul>
            <li>
                input (either custom or build-in component/markup 
                i.e. <mark>&lt;InputNumber @@bind-Value="@@rateContext.MaxRate" /&gt;</mark>),
            </li>
            <li>
                validation message (either custom or build-in component/markup 
                i.e. <mark>&lt;ValidationMessage For="@@(() =&gt; @@rateContext.MaxRate)" /&gt;</mark>),
            </li>
        </ul>

        <p>
            Of course both parameters of the <mark>RenderFragment</mark> type can accept any other markup as well.
        </p>

        <p>
            <strong>Note:</strong> without the <mark>Components.DataAnnotations.Validation</mark> package, Blazor is not able 
            to validate complex types (the package provides <mark>ObjectGraphDataAnnotationsValidator</mark>
            component to make a replacement for <mark>DataAnnotationsValidator</mark>. That component supports additional
            validation attributes defined within the package i.e. <mark>ValidateComplexType</mark>).
        </p>
    };

    private static readonly string BUILD_IN_FORM_COMPONENTS = "https://docs.microsoft.com/en-us/aspnet/core/blazor/forms-validation?view=aspnetcore-5.0#built-in-forms-components";
    private static readonly string EXAMPLE = "https://docs.microsoft.com/en-us/aspnet/core/blazor/forms-validation?view=aspnetcore-5.0#inputtext-based-on-the-input-event";
    private static readonly string INHERITS = "https://docs.microsoft.com/en-us/aspnet/core/mvc/views/razor?view=aspnetcore-5.0#inherits";
    private static readonly string ATTRIBUTE_SPATTING = "https://docs.microsoft.com/en-us/aspnet/core/blazor/components/?view=aspnetcore-5.0#attribute-splatting-and-arbitrary-parameters";
    private static readonly string DOCUMENTATION = "https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.components.forms.inputnumber-1?view=aspnetcore-5.0";
    private static readonly string READ_MORE_3 = "https://docs.microsoft.com/en-us/aspnet/core/blazor/components/templated-components?view=aspnetcore-5.0#template-parameters";
    private static readonly string READ_MORE_4 = "https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.components.forms.editcontext.notifyvalidationstatechanged?view=aspnetcore-5.0";
    private static readonly string ATTRIBUTE = "https://developer.mozilla.org/pl/docs/Web/HTML/Element/Input";
    private static readonly string ATTRIBUTE_SPATTING_2 = "https://docs.microsoft.com/en-us/aspnet/core/blazor/components/?view=aspnetcore-5.0#attribute-splatting-and-arbitrary-parameters";
    private static readonly string READ_MORE_5 = "https://docs.microsoft.com/en-us/aspnet/core/blazor/webassembly-performance-best-practices?view=aspnetcore-5.0#avoid-attribute-splatting-with-captureunmatchedvalues";
    private static readonly string READ_MORE_6 = "https://docs.microsoft.com/en-us/aspnet/core/blazor/components/?view=aspnetcore-5.0#attribute-splatting-and-arbitrary-parameters";

    internal static readonly RenderFragment PointContext2 = __builder =>
    {
        <p>
            Providing invalid values for either of the <mark>Max rate</mark> or <mark>Avg rate</mark> inputs will cause the application 
            to rise exceptions. Displaying validation errors with <mark>DataAnnotationsValidator</mark> 
            or <mark>ValidationSummary</mark> won't prevent a user to input those values.
        </p>

        <p>
            Create new <mark>AvgRateInputNumber</mark> Razor component that derives 
            from the <a href="@BUILD_IN_FORM_COMPONENTS">build-in</a> <mark>InputNumber&lt;TValue&gt;</mark> component 
            (see the <a href="@EXAMPLE">example</a>):
        </p>

        <pre>
            <code class="language-csharp line-numbers">
@@typeparam TValue
@@inherits InputNumber&lt;TValue&gt;

&lt;input
    @@attributes="AdditionalAttributes"
    class="@@CssClass"
    value="@@CurrentValue"
    @@oninput="@@((value) =&gt; CurrentValueAsString = value.Value?.ToString())" /&gt;
            </code>
        </pre>

        <p>
            <mark>InputNumber&lt;TValue&gt;</mark> component which the <mark>AvgRateInputNumber</mark> 
            <a href="@INHERITS">@@inherits</a> defines:
        </p>

        <ul>
            <li>
                <mark>AdditionalAttributes</mark> - a dictionary type parameter that will capture all <strong>DOM</strong>
                attributes that were provided to the component but the component does not define them as its parameters.
                This allows to pass through any attributes and their values down the tree of components/sub-components, 
                making components in the tree to capture a needed subset of attributes.
                It is mainly used for <a href="@ATTRIBUTE_SPATTING">attributes splatting</a> to provide attributes 
                to any non-blazor markup (like <mark>&lt;input&gt;</mark>).
            </li>
            <li>
                <mark>CssClass</mark> - a readonly property that represents the value of the <mark>class</mark> attribute 
                that was captured by the <mark>AdditionalAttributes</mark> dictionary (i.e. <mark>&lt;ADDITIONAL CLASSES&gt;</mark>
                for the <mark>&lt;AvgRateInputNumber class="&lt;ADDITIONAL CLASSES&gt;" ... /&gt;</mark>). <strong>CSS</strong> 
                classes defined in that way will be merged with validation-specific <strong>CSS</strong> classes
                that inherited <mark>InputNumber&lt;TValue&gt;</mark> class handles.
            </li>
            <li>
                <mark>CurrentValue</mark> - wrapper for the <mark>Value</mark> parameter of the <mark>InputNumber&lt;TValue&gt;</mark> 
                component. On that property change, value binded to the input will be updated -
                <mark>Value</mark> will be notified of that change and <mark>@@bind-Value</mark> markup will propagate 
                the change to it's value (i.e. <mark>VALUE</mark> for 
                the <mark>&lt;AvgRateInputNumber @@bind-Value="&lt;VALUE&gt;" ... /&gt;</mark>).
            </li>
            <li>
                <mark>CurrentValueAsString</mark> - as it is named, the property wraps the <mark>CurrentValue</mark>
                and provide its <mark>string</mark> representation on get (by <mark>FormatValueAsString</mark> method, which
                by default is implemented as <mark>CurrentValue.ToString()</mark>) and converts the given <mark>string</mark>
                to the <mark>TValue</mark> type, allowing the value to be assigned to the <mark>CurrentValue</mark>
                (which in turn will trigger <mark>Value</mark> parameter change and in that way
                the variable binded with the <mark>@@bind-Value</mark> directive will be updated).
            </li>
        </ul>

        <p>
            <strong>Note:</strong> <mark>InputNumber&lt;TValue&gt;</mark> accepts a generic type (based on the 
            <a href="@DOCUMENTATION">documentation</a>, component's <mark>TValue</mark> can be any 
            of the <strong>.NET</strong> numeric types).
            In order to mark the custom <mark>AvgRateInputNumber </mark> Razor component as generic, 
            <mark>@@typeparam</mark> attribute has to be used (<a href="@READ_MORE_3">read more</a>).
            Attribute can be omitted if the component inherits from the <mark>InputNumber&lt;TValue&gt;</mark> 
            but the generic type of the base class is fixed (i.e. <mark>InputNumber&lt;int&gt;</mark>):
        </p>

        <div class="example-figure">
            <figure>
                <div>
                    <pre data-line="1,2">
                        <code class="language-csharp line-numbers">
@@typeparam TValue
@@inherits InputNumber&lt;TValue&gt;

&lt;!-- ... --&gt;
                        </code>
                    </pre>
                </div>
                <figcaption>
                    <span>Generated class signature:</span>
                    <mark>partial AvgRateInputNumber&lt;TValue&gt; : InputNumber&lt;TValue&gt;</mark>
                </figcaption>
            </figure>
            <figure>
                <div>
                    <pre data-line="1">
                        <code class="language-csharp line-numbers">
@@inherits InputNumber&lt;int&gt;

&lt;!-- ... --&gt;
                        </code>
                    </pre>
                </div>
                <figcaption>
                    <span>Generated class signature:</span>
                    <mark>partial AvgRateInputNumber : InputNumber&lt;int&gt;</mark>
                </figcaption>
            </figure>
        </div>

        <p>
            <mark>AvgRateInputNumber</mark> alters the default behavior of the <mark>InputNumber</mark> component 
            to notify the <mark>EditForm</mark> component of the input change on every change (using <mark>input</mark> event) 
            - by default <mark>EditForm</mark> will be notified of the change only on the input's <mark>change</mark> event 
            (i.e. after moving to the next <mark>&lt;input&gt;</mark> control - <a href="@READ_MORE_4">read more</a>):
        </p>

        <div class="example-figure">
            <figure>
                <div>
                    <Capgemini.Net.Blazor.Components.Demo.Examples.Demo08.PointContext2 Example="1" />
                </div>
                <figcaption>
                    <span>default value change triggers validation on input's <mark>change</mark> event</span>
                </figcaption>
            </figure>
            <figure>
                <div>
                    <Capgemini.Net.Blazor.Components.Demo.Examples.Demo08.PointContext2 Example="2" />
                </div>
                <figcaption>
                    <span>custom value change triggers validation on input's <mark>input</mark> event</span>
                </figcaption>
            </figure>
        </div>

        <p>
            <strong>Note:</strong> <mark>&lt;input&gt;</mark> field of numeric type (<mark>type="number"</mark>) allows the user
            to change its value with arrow keys (<mark>[↑]</mark> and <mark>[↓]</mark>).
            Changing the value in that way will trigger the <mark>input</mark>, not <mark>change</mark> event.
            The second event is triggered if the user selects the input's value, provides a new one as a string and leaves the field.
        </p>

        <p>
            Update the <mark>ContainerComponent</mark> razor file with the custom <mark>AvgRateInputNumber</mark> component:
        </p>

        <pre data-line="7">
            <code class="language-csharp line-numbers">
&lt;div class="demo__container_wrapper"&gt;
    &lt;EditForm Model="@@rateContext"&gt;
        &lt;DataAnnotationsValidator /&gt;

        &lt;CapInput Label="Max rate" InputName="@@nameof(rateContext.MaxRate)"&gt;
            &lt;ChildContent&gt;
                &lt;AvgRateInputNumber @@bind-Value="@@rateContext.MaxRate" type="number" /&gt;
            &lt;/ChildContent&gt;
            &lt;ValidationContent&gt;
                &lt;ValidationMessage For="@@(() =&gt; @@rateContext.MaxRate)" /&gt;
            &lt;/ValidationContent&gt;
        &lt;/CapInput&gt;

		&lt;!-- ... --&gt;
    &lt;/EditForm&gt;

    &lt;!-- ... --&gt;
&lt;/div&gt;

            </code>
        </pre>

        <p>
            <strong>Note:</strong> <mark>type="number"</mark> attribute key-value pair will be captured by the internal 
            <mark>AdditionalAttributes</mark> dictionary parameter. <mark>Type</mark> is an <a href="@ATTRIBUTE">attribute</a> 
            for the <mark>&lt;input&gt;</mark> markup and it is passed with other attributes, captured by this dictionary:
        </p>

        <div class="example-figure">
            <figure>
                <div>
                    <Capgemini.Net.Blazor.Components.Demo.Examples.Demo08.PointContext2 Example="3" />
                </div>
                <figcaption>
                    <mark>&lt;AvgRateInputNumber @@bind-Value="@@rateContext.MaxRate" /&gt;</mark>
                    <span>(<mark>type="text"</mark> by default)</span>
                </figcaption>
            </figure>
            <figure>
                <div>
                    <Capgemini.Net.Blazor.Components.Demo.Examples.Demo08.PointContext2 Example="4" />
                </div>
                <figcaption>
                    <mark>&lt;AvgRateInputNumber @@bind-Value="@@rateContext.MaxRate" type="number" /&gt;</mark>
                    <span>(enables value change on <mark>[↑]</mark> and <mark>[↓]</mark> keys)</span>
                </figcaption>
            </figure>
        </div>

        <p>
            <mark>&lt;input&gt;</mark> tag with a <mark>type="number"</mark> supports useful range of attributes like:
        </p>

        <ul>
            <li>
                <mark>min</mark>,
            </li>
            <li>
                <mark>max</mark>,
            </li>
            <li>
                <mark>step</mark>
            </li>
        </ul>

        <p>
            which can be used to make the values of those inputs be bounded by the required properties 
            without changing the <mark>AvgRateInputNumber</mark>/<mark>InputNumber</mark> components
            or any other that derives from <mark>InputBase</mark> (thanks to the <mark>AdditionalAttributes</mark> parameter 
            it provides and passes all captured key-value pairs as attributes for the <mark>&lt;input&gt;</mark>).
            Modify the <mark>ContainerComponent</mark> to include those extra attributes:
        </p>

        <pre data-line="10, 22-23">
            <code class="language-csharp line-numbers">
&lt;div class="demo__container_wrapper"&gt;
    &lt;EditForm Model="@@rateContext"&gt;
        &lt;DataAnnotationsValidator /&gt;

        &lt;CapInput Label="Max rate" InputName="@@nameof(rateContext.MaxRate)"&gt;
            &lt;ChildContent&gt;
                &lt;AvgRateInputNumber
                    @@bind-Value="@@rateContext.MaxRate"
                    type="number"
                    min="@@rateContext.AvgRate" /&gt;
            &lt;/ChildContent&gt;
            &lt;ValidationContent&gt;
                &lt;ValidationMessage For="@@(() =&gt; @@rateContext.MaxRate)" /&gt;
            &lt;/ValidationContent&gt;
        &lt;/CapInput&gt;

        &lt;CapInput Label="Avg rate" InputName="@@nameof(rateContext.AvgRate)"&gt;
            &lt;ChildContent&gt;
                &lt;AvgRateInputNumber
                    @@bind-Value="@@rateContext.AvgRate"
                    type="number"
                    min="2"
                    max="@@rateContext.MaxRate" /&gt;
            &lt;/ChildContent&gt;
            &lt;ValidationContent&gt;
                &lt;ValidationMessage For="@@(() =&gt; @@rateContext.AvgRate)" /&gt;
            &lt;/ValidationContent&gt;
        &lt;/CapInput&gt;

        &lt;CapSelect Label="Icon" @@bind-Value="rateContext.Icon"&gt;
            @@foreach (string icon in RateContext.Icons)
            {
                &lt;CapOption Key="@@icon" Value="@@icon"&gt;
                    &lt;div class="fa-cap-option"&gt;
                        &lt;i class="far @@icon" /&gt; - &lt;strong&gt;@@icon&lt;/strong&gt;
                    &lt;/div&gt;
                &lt;/CapOption&gt;
            }
        &lt;/CapSelect&gt;
    &lt;/EditForm&gt;

    &lt;div class="demo__container"&gt;
        @@ChildContent(rateContext)
    &lt;/div&gt;

    &lt;div class="average-rate-container"&gt;
        @@AvgRate(AverageRateContext)
    &lt;/div&gt;
&lt;/div&gt;
            </code>
        </pre>

        <p>
            <strong>Note:</strong> usage of <a href="@ATTRIBUTE_SPATTING_2">attribute splatting</a> is not recommended
            from the performance point of view. Care must be taken if a parameter marked with 
            <mark>[Parameter(CaptureUnmatchedValues = true)]</mark> is used for a components with multiple instances 
            in the application (i.e. rendered by a loop) - <a href="@READ_MORE_5">read more</a>.
        </p>

        <p>
            <strong>Note:</strong> position of the <mark>@@attributes="AdditionalAttributes"</mark> attribute matters. 
            By default when <mark>@@attributes</mark> are splatted on the element,
            the attributes are processed from right to left 
            (<a href="@READ_MORE_6">read more</a>).
        </p>
    };

    private static readonly string READ_MORE_7 = "https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.components.forms.editcontext.onfieldchanged?view=aspnetcore-5.0";
    private static readonly string READ_MORE_8 = "https://docs.microsoft.com/en-us/aspnet/core/blazor/components/lifecycle?view=aspnetcore-5.0#component-disposal-with-idisposable";

    internal static readonly RenderFragment PointContext3 = __builder =>
    {
        <p>
            Although either of <mark>AvgRateInputNumber</mark> inputs aren't allowed the invalid values to be selected, 
            changing value of one input can still generate an invalid state of the application (i.e. decreasing the value 
            of the <mark>MaxRate</mark> property will decrease the allowed range of the <mark>AvgRate</mark> input and at some point
            the value of that input might extend the <mark>max="@@rateContext.MaxRate"</mark>, throwing a runtime exception in result).
            To fix that values of both inputs has to be connected to each other.
        </p>

        <p>
            Create the <mark>./Start/MaxRateInputNumber.razor</mark> file with the given content:
        </p>

        <pre data-line="2, 13, 17-18, 22-26, 31">
            <code class="language-csharp line-numbers">
@@typeparam TValue
@@inherits RateInputNumberBase&lt;TValue&gt;
@@implements IDisposable

&lt;input @@attributes="AdditionalAttributes"
       class="@@CssClass"
       value="@@CurrentValue"
       @@oninput="@@((value) =&gt; CurrentValueAsString = value.Value?.ToString())" /&gt;

@@code {
    protected override void OnInitialized()
    {
        EditContext.OnFieldChanged += HandleFieldChanged;
        base.OnInitialized();
    }

    private void HandleFieldChanged(object? sender, FieldChangedEventArgs e)
        =&gt; OnSelectedFieldChanged&lt;RateContext&gt;(nameof(RateContext.AvgRate), e, UpdateField);

    private void UpdateField(RateContext model, FieldIdentifier fieldIdentifier)
    {
        if (model.MaxRate &lt; model.AvgRate)
        {
            CurrentValueAsString = model.AvgRate.ToString();
            EditContext.Validate();
        }
    }

    public void Dispose()
    {
        EditContext.OnFieldChanged -= HandleFieldChanged;
    }
}
            </code>
        </pre>

        <ul>
            <li>
                The component inherits from the <mark>RateInputNumberBase&lt;TValue&gt;</mark> class (line <mark>2</mark>). 
                The class provides the <mark>OnSelectedFieldChanged&lt;T&gt;(string fieldName, FieldChangedEventArgs args, 
                Action&lt;T, FieldIdentifier&gt; action)</mark> method which will trigger an <mark>action</mark>
                whenever a value of the <mark>fieldName</mark> input changed.
            </li>
            <li>
                <mark>EditForm</mark> component that wraps inputs for <mark>MaxRate</mark>, <mark>AvgRate</mark> 
                and <mark>Icon</mark> provides a <mark>EditContext</mark> object for all of them:

                <pre>
                    <code class="language-csharp line-numbers">
&lt;!-- ... --&gt;

&lt;EditForm Model="@@rateContext"&gt;
	&lt;!-- ... --&gt;
&lt;/EditForm&gt;

&lt;!-- ... --&gt;
                    </code>
                </pre>

                This object is shared across all inputs inside the given <mark>EditForm</mark> (<mark>EditContext</mark>
                that the <mark>EditForm</mark> is building based on the provided model <mark>Model="@@rateContext"</mark> 
                is shared by the usage of <mark>AdditionalAttributes</mark> component like so: 
                <mark>&lt;CascadingValue IsFixed="true" Value="_editContext"&gt;</mark>).
                Line <mark>13</mark> is using one of the <mark>EditContext</mark>'s events to make a subscription
                for any input value change (<a href="@READ_MORE_7">read more</a>).
            </li>
            <li>
                With <mark>OnFieldChanged</mark> callback raised because of the <mark>AvgRate</mark> input has changed, 
                method called by the <mark>HandleFieldChanged</mark> (lines <mark>17-18</mark>) makes the <mark>UpdateField</mark> method 
                to be executed (<mark>OnFieldChanged</mark> is called upon any input value change but <mark>OnSelectedFieldChanged</mark> 
                filters those calls and passes through only the callbacks triggered by the <mark>RateContext.AvgRate</mark> input).
            </li>
            <li>
                If the <mark>AvgRate</mark> change would result in <mark>AvgRate</mark> to be greater than <mark>MaxRate</mark> 
                (which would make the <mark>AvgRate</mark> value invalid, resulting in throwing an exception),
                input's value for <mark>MaxRate</mark> will be updated to be the same as <mark>AvgRate</mark> (lines <mark>22-26</mark>). 
                Then the validation will be triggered (otherwise the validation result from the validation triggered 
                by the <mark>[CompareTo(CompareToAttribute.CompareTo.LESS_THAN_OR_EQUAL, "MaxRate")]</mark>
                before the <mark>MaxRate</mark> had a chance to be updated, won't be overwritten).
            </li>
            <li>
                On component destruction, any subscription done to the <mark>OnFieldChanged</mark> event 
                has to be disposed gracefully (line <mark>31</mark>) - <a href="@READ_MORE_8">read more</a>.
            </li>
        </ul>

        <p>
            Replace the content for the other input custom component - <mark>AvgRateInputNumber</mark>. 
            Add same <mark>@@code {}</mark> block as <mark>MaxRateInputNumber</mark> has
            (change the filed name that the component is listening for from <mark>nameof(RateContext.AvgRate)</mark> 
            to <mark>nameof(RateContext.MaxRate)</mark> and the property to be assigned to the <mark>CurrentValueAsString</mark>
            - from <mark>AvgRate</mark> to <mark>MaxRate</mark>):
        </p>

        <pre data-line="2, 18, 24">
            <code class="language-csharp line-numbers">
@@typeparam TValue
@@inherits RateInputNumberBase&lt;TValue&gt;
@@implements IDisposable

&lt;input @@attributes="AdditionalAttributes"
       class="@@CssClass"
       value="@@CurrentValue"
       @@oninput="@@((value) =&gt; CurrentValueAsString = value.Value?.ToString())" /&gt;

@@code {
    protected override void OnInitialized()
    {
        EditContext.OnFieldChanged += HandleFieldChanged;
        base.OnInitialized();
    }

    private void HandleFieldChanged(object? sender, FieldChangedEventArgs e)
        =&gt; OnSelectedFieldChanged&lt;RateContext&gt;(<mark>nameof(RateContext.MaxRate)</mark>, e, UpdateField);

    private void UpdateField(RateContext model, FieldIdentifier fieldIdentifier)
    {
        if (model.MaxRate &lt; model.AvgRate)
        {
            CurrentValueAsString = model.<mark>MaxRate</mark>.ToString();
            EditContext.Validate();
        }
    }

    public void Dispose()
    {
        EditContext.OnFieldChanged -= HandleFieldChanged;
    }
}
            </code>
        </pre>

        <p>
            Remove the <mark>min</mark> and <mark>max</mark> boundaries for both input components 
            in the <mark>ContainerComponent</mark> (except for the default <mark>min="2"</mark>). 
            Replace the <mark>AvgRateInputNumber</mark> component for the <mark>Max rate</mark> input 
            to the <mark>MaxRateInputNumber</mark> component:
        </p>

        <pre data-line="7-10, 19-22">
            <code class="language-csharp line-numbers">
&lt;div class="demo__container_wrapper"&gt;
    &lt;EditForm Model="@@rateContext"&gt;
        &lt;DataAnnotationsValidator /&gt;

        &lt;CapInput Label="Max rate" InputName="@@nameof(rateContext.MaxRate)"&gt;
            &lt;ChildContent&gt;
                &lt;<mark>MaxRateInputNumber</mark>
                    @@bind-Value="@@rateContext.MaxRate"
                    type="number"
                    min="2" /&gt;
            &lt;/ChildContent&gt;
            &lt;ValidationContent&gt;
                &lt;ValidationMessage For="@@(() =&gt; @@rateContext.MaxRate)" /&gt;
            &lt;/ValidationContent&gt;
        &lt;/CapInput&gt;

        &lt;CapInput Label="Avg rate" InputName="@@nameof(rateContext.AvgRate)"&gt;
            &lt;ChildContent&gt;
                &lt;AvgRateInputNumber
                    @@bind-Value="@@rateContext.AvgRate"
                    type="number"
                    min="2" /&gt;
            &lt;/ChildContent&gt;
            &lt;ValidationContent&gt;
                &lt;ValidationMessage For="@@(() =&gt; @@rateContext.AvgRate)" /&gt;
            &lt;/ValidationContent&gt;
        &lt;/CapInput&gt;

        &lt;CapSelect Label="Icon" @@bind-Value="rateContext.Icon"&gt;
            @@foreach (string icon in RateContext.Icons)
            {
                &lt;CapOption Key="@@icon" Value="@@icon"&gt;
                    &lt;div class="fa-cap-option"&gt;
                        &lt;i class="far @@icon" /&gt; - &lt;strong&gt;@@icon&lt;/strong&gt;
                    &lt;/div&gt;
                &lt;/CapOption&gt;
            }
        &lt;/CapSelect&gt;
    &lt;/EditForm&gt;

    &lt;div class="demo__container"&gt;
        @@ChildContent(rateContext)
    &lt;/div&gt;

    &lt;div class="average-rate-container"&gt;
        @@AvgRate(AverageRateContext)
    &lt;/div&gt;
&lt;/div&gt;
            </code>
        </pre>

        <p>
            <strong>Note:</strong> both <mark>@@code {}</mark> blocks for <mark>AvgRateInputNumber</mark> 
            and <mark>MaxRateInputNumber</mark> can be simplified with the 
            <mark>Capgemini.Net.Blazor.Components.Demo.RateInputNumberAbstractBase</mark> class.
            See final <mark>AvgRateInputNumber</mark>:
        </p>

        <pre>
            <code class="language-csharp line-numbers">
@@typeparam TValue
@@inherits RateInputNumberAbstractBase&lt;TValue&gt;
@@implements IDisposable

&lt;input @@attributes="AdditionalAttributes"
       class="@@CssClass"
       value="@@CurrentValue"
       @@oninput="@@((value) =&gt; CurrentValueAsString = value.Value?.ToString())" /&gt;

@@code {
    protected override void HandleFieldChanged(object? sender, FieldChangedEventArgs e)
        =&gt; OnSelectedFieldChanged&lt;RateContext&gt;(nameof(RateContext.MaxRate), e, UpdateField);

    private void UpdateField(RateContext model, FieldIdentifier fieldIdentifier)
    {
        if (model.MaxRate &lt; model.AvgRate)
        {
            CurrentValueAsString = model.MaxRate.ToString();
            EditContext.Validate();
        }
    }
}
            </code>
        </pre>

        <p>
            ...and <mark>MaxRateInputNumber</mark> code:
        </p>

        <pre>
            <code class="language-csharp line-numbers">
@@typeparam TValue
@@inherits RateInputNumberAbstractBase&lt;TValue&gt;
@@implements IDisposable

&lt;input @@attributes="AdditionalAttributes"
       class="@@CssClass"
       value="@@CurrentValue"
       @@oninput="@@((value) =&gt; CurrentValueAsString = value.Value?.ToString())" /&gt;

@@code {
    protected override void HandleFieldChanged(object? sender, FieldChangedEventArgs e)
        =&gt; OnSelectedFieldChanged&lt;RateContext&gt;(nameof(RateContext.AvgRate), e, UpdateField);

    private void UpdateField(RateContext model, FieldIdentifier fieldIdentifier)
    {
        if (model.MaxRate &lt; model.AvgRate)
        {
            CurrentValueAsString = model.AvgRate.ToString();
            EditContext.Validate();
        }
    }
}
            </code>
        </pre>
    };

    private static readonly string READ_MORE_9 = "https://docs.microsoft.com/en-us/aspnet/core/blazor/components/data-binding?view=aspnetcore-5.0";
    private static readonly string DIRECTIVE_ATTRIBUTES = "https://docs.microsoft.com/en-us/aspnet/core/blazor/components/?view=aspnetcore-5.0#razor-syntax";
    private static readonly string SEE_EXAMPLE = "https://docs.microsoft.com/en-us/aspnet/core/blazor/components/event-handling?view=aspnetcore-5.0#prevent-default-actions";
    private static readonly string SEE_EXAMPLE_1 = "https://docs.microsoft.com/en-us/aspnet/core/blazor/components/event-handling?view=aspnetcore-5.0#stop-event-propagation";

    internal static readonly RenderFragment PointContext4 = __builder =>
    {
        <p>
            Both <mark>MaxRateInputNumber</mark> and <mark>AvgRateInputNumber</mark> components can still be set to invalid values, 
            as by default <mark>min</mark>, <mark>max</mark> and <mark>step</mark> attributes
            only works if the value is selected by any of the arrow keys (<mark>[↑]</mark> and <mark>[↓]</mark>). 
            Those parameters don't work if a user changes the value of the input in the other way (i.e. by deleting the content 
            of the input and type a new value manually).
        </p>

        <p>
            Create a new base class for <mark>MaxRateInputNumber</mark> and <mark>AvgRateInputNumber</mark> components 
            - <mark>RateInputMinMaxNumberAbstractBase</mark>:
        </p>

        <pre data-line="10-11, 13-14, 27-35">
            <code class="language-csharp line-numbers">
using Capgemini.Net.Blazor.Components.Demo;
using Microsoft.AspNetCore.Components;
using System;
using System.Diagnostics.CodeAnalysis;

namespace Capgemini.Net.Blazor.Components.Demo08.Start
{
    public abstract class RateInputMinMaxNumberAbstractBase&lt;TValue&gt; : RateInputNumberAbstractBase&lt;TValue&gt;
    {
        [Parameter]
        public TValue Min { get; set; } = default!;

        [Parameter]
        public TValue Max { get; set; } = default!;

        protected override bool TryParseValueFromString(
            string? value,
            [MaybeNullWhen(false)] out TValue result,
            [NotNullWhen(false)] out string? validationErrorMessage)
        {
            if (base.TryParseValueFromString(value, out result, out validationErrorMessage))
            {
                IComparable&lt;TValue&gt;? selfValueComparer = result as IComparable&lt;TValue&gt;;

                if (selfValueComparer is not null)
                {
                    if (Min is not null && selfValueComparer.CompareTo(Min) &lt; 0)
                    {
                        result = Min;
                    }

                    if (Max is not null && selfValueComparer.CompareTo(Max) &gt; 0)
                    {
                        result = Max;
                    }
                }

                return true;
            }

            return false;
        }
    }
}
            </code>
        </pre>

        <p>
            <mark>RateInputMinMaxNumberAbstractBase</mark> class adds custom parameters for <mark>Min</mark> and <mark>Max</mark> 
            (lines <mark>10-11</mark>, <mark>13-14</mark>). Those parameters will be used to replace the default 
            <mark>min</mark>, <mark>max</mark> attributes for the <mark>&lt;input&gt;</mark> components that were used.
        </p>

        <p>
            The class overwrites the <mark>TryParseValueFromString</mark> method which is used by the <mark>InputBase&lt;TValue&gt;</mark> 
            to update the <mark>CurrentValue</mark> (of type <mark>TValue</mark>) if the
            <mark>CurrentValueAsString</mark> is changed - like on the <mark>input</mark> event in line <mark>10</mark>:
        </p>

        <pre data-line="10">
            <code class="language-csharp line-numbers">
@@typeparam TValue
@@inherits RateInputNumberAbstractBase&lt;TValue&gt;
@@implements IDisposable

&lt;!-- ... --&gt;

&lt;input @@attributes="AdditionalAttributes"
       class="@@CssClass"
       value="@@CurrentValue"
       @@oninput="@@((value) =&gt; <mark>CurrentValueAsString = value.Value?.ToString())</mark>" /&gt;

@@code {
	// ...
}
            </code>
        </pre>

        <p>
            It handles the conversion to the <mark>TValue</mark> type and returns it by the <mark>result</mark> output parameter. 
            By adding a custom logic, this value can be forced to not extend any of the <mark>Min</mark> 
            or <mark>Max</mark> parameters (lines <mark>27-35</mark>).
        </p>

        <p>
            Replace the class that both <mark>MaxRateInputNumber</mark> and <mark>AvgRateInputNumber</mark> inherits 
            from <mark>RateInputNumberAbstractBase</mark> to the <mark>RateInputMinMaxNumberAbstractBase</mark> abstract class:
        </p>

        <pre data-line="2">
            <code class="language-csharp line-numbers">
@@typeparam TValue
@@inherits <mark>RateInputMinMaxNumberAbstractBase</mark>&lt;TValue&gt;
@@implements IDisposable

&lt;!-- ... --&gt;

&lt;input @@attributes="AdditionalAttributes"
       class="@@CssClass"
       value="@@CurrentValue"
       @@oninput="@@((value) =&gt; CurrentValueAsString = value.Value?.ToString())" /&gt;

@@code {
	// ...
}
            </code>
        </pre>

        <pre data-line="2">
            <code class="language-csharp line-numbers">
@@typeparam TValue
@@inherits <mark>RateInputMinMaxNumberAbstractBase</mark>&lt;TValue&gt;
@@implements IDisposable

&lt;!-- ... --&gt;

&lt;input @@attributes="AdditionalAttributes"
       class="@@CssClass"
       value="@@CurrentValue"
       @@oninput="@@((value) =&gt; CurrentValueAsString = value.Value?.ToString())" /&gt;

@@code {
	// ...
}
            </code>
        </pre>

        <p>
            Update the markup of the <mark>ContainerComponent</mark> to use <mark>Min</mark>, <mark>Max</mark> parameters, 
            provided by the new base class:
        </p>

        <pre data-line="9-10, 22-23">
            <code class="language-csharp line-numbers">
&lt;div class="demo__container_wrapper"&gt;
    &lt;EditForm Model="@@rateContext"&gt;
        &lt;DataAnnotationsValidator /&gt;

        &lt;CapInput Label="Max rate" InputName="@@nameof(rateContext.MaxRate)"&gt;
            &lt;ChildContent&gt;
                &lt;MaxRateInputNumber
                    @@bind-Value="@@rateContext.MaxRate"
                    Min="@@rateContext.AvgRate"
                    Max="@@int.MaxValue"
                    type="number" /&gt;
            &lt;/ChildContent&gt;
            &lt;ValidationContent&gt;
                &lt;ValidationMessage For="@@(() =&gt; @@rateContext.MaxRate)" /&gt;
            &lt;/ValidationContent&gt;
        &lt;/CapInput&gt;

        &lt;CapInput Label="Avg rate" InputName="@@nameof(rateContext.AvgRate)"&gt;
            &lt;ChildContent&gt;
                &lt;AvgRateInputNumber
                    @@bind-Value="@@rateContext.AvgRate"
                    Min="2"
                    Max="@@rateContext.MaxRate"
                    type="number" /&gt;
            &lt;/ChildContent&gt;
            &lt;ValidationContent&gt;
                &lt;ValidationMessage For="@@(() =&gt; @@rateContext.AvgRate)" /&gt;
            &lt;/ValidationContent&gt;
        &lt;/CapInput&gt;

        &lt;CapSelect Label="Icon" @@bind-Value="rateContext.Icon"&gt;
            @@foreach (string icon in RateContext.Icons)
            {
                &lt;CapOption Key="@@icon" Value="@@icon"&gt;
                    &lt;div class="fa-cap-option"&gt;
                        &lt;i class="far @@icon" /&gt; - &lt;strong&gt;@@icon&lt;/strong&gt;
                    &lt;/div&gt;
                &lt;/CapOption&gt;
            }
        &lt;/CapSelect&gt;
    &lt;/EditForm&gt;

    &lt;div class="demo__container"&gt;
        @@ChildContent(rateContext)
    &lt;/div&gt;

    &lt;div class="average-rate-container"&gt;
        @@AvgRate(AverageRateContext)
    &lt;/div&gt;
&lt;/div&gt;
            </code>
        </pre>

        <p>
            Finally update the markup of both <mark>MaxRateInputNumber</mark> and <mark>AvgRateInputNumber</mark> components. 
            Replace the <mark>value</mark> attribute and the <mark>@@oninput</mark> directive:
        </p>

        <pre data-line="7-8">
            <code class="language-csharp line-numbers">
@@typeparam TValue
@@inherits RateInputMinMaxNumberAbstractBase&lt;TValue&gt;
@@implements IDisposable

&lt;input @@attributes="AdditionalAttributes"
       class="@@CssClass"
       @@bind-value="@@CurrentValueAsString"
       @@bind-value:event="oninput" /&gt;

@@code {
    protected override void HandleFieldChanged(object? sender, FieldChangedEventArgs e)
        =&gt; OnSelectedFieldChanged&lt;RateContext&gt;(nameof(RateContext.AvgRate), e, UpdateField);

    private void UpdateField(RateContext model, FieldIdentifier fieldIdentifier)
    {
        if (model.MaxRate &lt; model.AvgRate)
        {
            CurrentValueAsString = model.AvgRate.ToString();
            EditContext.Validate();
        }
    }
}
            </code>
        </pre>

        <pre data-line="7-8">
            <code class="language-csharp line-numbers">
@@typeparam TValue
@@inherits RateInputMinMaxNumberAbstractBase&lt;TValue&gt;
@@implements IDisposable

&lt;input @@attributes="AdditionalAttributes"
       class="@@CssClass"
       @@bind-value="@@CurrentValueAsString"
       @@bind-value:event="oninput" /&gt;

@@code {
    protected override void HandleFieldChanged(object? sender, FieldChangedEventArgs e)
        =&gt; OnSelectedFieldChanged&lt;RateContext&gt;(nameof(RateContext.MaxRate), e, UpdateField);

    private void UpdateField(RateContext model, FieldIdentifier fieldIdentifier)
    {
        if (model.MaxRate &lt; model.AvgRate)
        {
            CurrentValueAsString = model.MaxRate.ToString();
            EditContext.Validate();
        }
    }
}
            </code>
        </pre>

        <p>
            In place of the deleted markup, the <mark>@@bind-value</mark> was used. By default it is a shorthand 
            for the given markup (<a href="@READ_MORE_9">read more</a>):
        </p>

        <pre data-line="7-9">
            <code class="language-csharp line-numbers">
@@typeparam TValue
@@inherits RateInputMinMaxNumberAbstractBase&lt;TValue&gt;
@@implements IDisposable

&lt;input @@attributes="AdditionalAttributes"
       class="@@CssClass"
       value="@@CurrentValueAsString"
       @@onchange="@@((ChangeEventArgs __e) =&gt; CurrentValueAsString = 
			__e.Value.ToString())" /&gt;

@@code {
	// ...
}
            </code>
        </pre>

        <p>
            By using a <a href="@DIRECTIVE_ATTRIBUTES">directive attribute</a> <mark>@@bind-value:event="oninput"</mark>
            the default event for the binding can be changed. By default that event is <mark>onchange</mark>. 
            With the event changed, the equivalent markup would be like this:
        </p>

        <pre data-line="7-9">
            <code class="language-csharp line-numbers">
@@typeparam TValue
@@inherits RateInputMinMaxNumberAbstractBase&lt;TValue&gt;
@@implements IDisposable

&lt;input @@attributes="AdditionalAttributes"
       class="@@CssClass"
       value="@@CurrentValueAsString"
       <mark>@@oninput</mark>="@@((ChangeEventArgs __e) =&gt; CurrentValueAsString = 
			__e.Value.ToString())" /&gt;

@@code {
	// ...
}
            </code>
        </pre>

        <p>
            and the new value will be assigned to the <mark>CurrentValueAsString</mark> variable on every input's change 
            (not only on input's blur).
        </p>

        <p>
            Directive attributes can also control other aspects of the event like:
        </p>

        <ul>
            <li>
                <mark>@@on{EVENT}:preventDefault</mark> - to prevent a default <mark>{EVENT}</mark> behavior 
                (<a href="@SEE_EXAMPLE">see example</a>),
            </li>
            <li>
                <mark>@@on{EVENT}:stopPropagation</mark> - to prevent the <mark>{EVENT}</mark> to be propagated 
                (<a href="@SEE_EXAMPLE_1">see example</a>).
            </li>
        </ul>

        <p>
            <strong>Note:</strong> by providing values for both <mark>Min</mark> and <mark>Max</mark> parameters, 
            field values will no longer be updated on other field's value change (i.e. <mark>Max rate</mark> won't be 
            changed alongside with the <mark>Avg rate</mark> if the last one would be increased in the way it's value would be 
            greater than <mark>Max rate</mark> - <mark>Max="@@rateContext.MaxRate"</mark> used to bound the value of the 
            <mark>AvgRateInputNumber</mark> will prevent the scenario from happening).
        </p>
    };
}